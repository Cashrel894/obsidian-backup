#CS61B 
主要想法是，将新增的元素在同一个结点中存储，从而避免造成 [[BSTs]] 的不平衡问题。
![[../../附件/Pasted image 20250904145856.png]]

可以手动设定一个结点元素数量上限，防止单个结点中存储的元素数量过多。（下取上限为 3 为例）

多余的元素怎么办？抽出中间的一个给父节点，剩下的分裂开来！
![[../../附件/Pasted image 20250904185018.png]]
当父节点存在两个元素时，该父结点的搜索树区间被分为了三块（~15, 15~17, 17~），因此可以同时拥有三个子节点，而结点的深度保持不变。

随着结点继续溢出，父节点有 n 个元素时，其就可以拥有 n+1 个子节点。

那么对于无父节点的根结点，满了又该如何处理呢？答案是新建一层。
![[../../附件/Pasted image 20250904185546.png]]
![[../../附件/Pasted image 20250904185554.png]]

这样一来，可以保证搜索树的高度被限制在 O (log n) 级别，大大提高了搜索和插入的效率。

> [!note] 
> 2-3 Trees 和 2-3-4 Trees 分别指的是限制为 3 和 4 的 B 树，表示结点可以拥有的子节点个数（除了 0）。



