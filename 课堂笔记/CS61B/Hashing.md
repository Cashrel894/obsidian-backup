#CS61B 
## Hashing
哈希化的定义：将一个拥有很多（或无限）成员的集合中的一个元素，映射到一个固定的、成员更少的集合的一个元素。

对于字符串的哈希，可以将整个字符串看作一个 P 进制的数（此处可使用 ASCII 或 Unicode）转换为十进制数再取模。

哈希冲突不可避免，因此我们需要解决冲突的方式。

## Collision Handling
### 链表法
将每个哈希值对应到一个“桶”（这个“桶”可以是链表或集合或其他合适的数据结构），如果新添加的元素在桶中不存在，就加入到桶中。
![[../../附件/Pasted image 20250906081121.png]]

## Resizing
随着数据量不断增大，最大“桶”的体积也在增长，意味着哈希表的查询修改复杂度增加，此时固定容积的哈希表的复杂度将退化为 `O(N)` 级别。（假设“桶”数为 M，数据量为 N，那么最大“桶”体积为 N / M 级别，即 `O(N)`）

因此，当 N 扩大时，我们的 M 也需要等比扩大，以维持哈希表的 `O(1)` 复杂度。

N / M 也被称为哈希表的“负载因子”。一种可行的策略是，当负载因子大于 1.5 时，将 M 翻倍。

> [!warning] 
> 1. 哈希表中不能存储可变的对象。
> 因为对象的变化会导致其哈希值的变化。
> 2. 如果覆写了 equals，也必须同时覆写 hashCode。
> 因为 Java 中的 HashMap 和 HashSet 使用了 equals 来判断元素是否存在桶中。

## Good HashCodes
一般来说，选用一个小质数为基可以较好地确保哈希的随机性，同时减少运算成本（如常用的是 31）。