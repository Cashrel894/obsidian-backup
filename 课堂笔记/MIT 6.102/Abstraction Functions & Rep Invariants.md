#mit6102 
## Invariants
一个好的抽象数据结构，总是能保持自身的某些**不变量**(Invariant)。
- 不变量有多种形式，例如不可修改性 (Immutability)、变量类型、变量之间的关系等。

为了保持不变量，数据结构通常会保护自身的私有变量不被外界直接访问，并只允许一些良定义的操作与数据结构进行互动。

保持不变量的好处有：
- 容易对代码进行形式推理。
- 容易进行调试，可以根据不变性轻松地排除很多情况。
- 减少客户端的误用行为。

## Immutability
在设计不可修改的数据类型时，需要注意可修改对象的使用，例如：
- 若直接将外界传入的可修改对象的引用赋给内部变量，该对象有可能发生修改，造成**表示泄露**(Rep Exporsure)。
- 在向外界直接传出可修改对象时，外界对对象的修改可能影响对象的不可变性。

因此，`private` 的字段不一定意味着不可访问，一旦有操作泄露了可修改对象的引用，外界就有可能通过引用作出意外修改。

## Rep Invariants and Abstraction Functions
**抽象值**(Abstract Value) ：指**客户端视角**下数据类型所支持的值。
**表示值**(Rep Value)：指**实现者视角**下用于实现抽象值的实际对象。

例如用 `string` 作为表示值，来实现抽象值 `CharSet`：
![[Pasted image 20260130134724.png]]

可以观察到两者之间的关系存在以下特点：
- 每个抽象值都**至少存在一个**映射到它的表示值。
- 多个表示值可以映射到一个抽象值。
- 并不是所有表示值都有一个抽象值与之对应。

为了进一步刻画两者之间的关联，我们引入以下两个概念：
1. **抽象函数**(Abstraction Function)：表示值到抽象值的一个映射，即 `AF: R -> A`。注意到抽象函数一定是**满射的**，但不一定单射，且通常定义域非全集。
2. **表示不变量**(Rep Invariant)：表示值到布尔值的一个映射，即 `RI: R -> boolean`。换句话说，表示不变量是对表示值的一个**谓词**，且满足 `RI(r)` 当且仅当 `r` 属于 `AF` 的定义域，即存在抽象值与 `r` 对应。

抽象函数和表示不变量都应该记录在代码注释中，例如：
```ts
class CharSet {
    private s: string;
    // Rep invariant:
    //   s contains no repeated characters
    // Abstraction function:
    //   AF(s) = {s[i] | 0 <= i < s.length}
    ...
}
```
这样的注释**非常重要**，特别是当 `AF` 并不明确的时候。