#mit6102 
## Deterministic vs. Underdeterministic specs
如果对于一个**满足前置条件**的输入，其结果完全确定，不随具体实现的替换而变化，那么就称这个规范是**确定的**(Deterministic)。

而结果不确定的，就称这个规范是**欠定的**(Underdeterministic)。注意，一个欠定的规范，可能是因为具体实现涉及到了随机过程，导致同一实现对于同一输出可能有着不同结果；也可能是因为，规范对后置条件的约束不足，合法的结果非唯一，返回哪个结果是由具体实现决定的（而实现本身可以是确定的）。

## Declarative vs. Operational specs
如果一个规范详细描述了模块执行的一系列步骤，就称其为**操作式的**(Operational)；反之，若规范只描述了最终结果的性质以及与初始状态的关系，就称其为**声明式的**(Declarative)。

通常，声明式的规范总是好于操作性的，因为它们简短、易于理解，同时也成功向客户端隐藏了实现细节，给具体实现更大的自由度。

## Stronger vs. Weaker specs
有时，我们不仅需要修改实现，还可能要修改规范本身。那么，在有很多客户端使用该模块的情况下，我们应该怎样替换规范，防止破坏客户端的正确性呢？

我们可以比较两个规范之间的**强度**。如果规范 2 的合法实现是规范 1 的合法实现的真子集，就称规范 2 **强于**(Stronger) 规范 1。

更进一步说，规范 2 强于规范 1 当且仅当：
- 规范 2 的前置条件弱于规范 1。
- **当满足规范 1 的前置条件时**，规范 2 的后置条件强于规范 1。
若规范 2 强于规范 1，那么满足规范 2 的实现也必然满足规范 1，我们就可以安全地用规范 2 来替换掉规范 1。

## Mutability
从结论上讲，**不可修改的**类型总是比可修改的类型更加 SFB、ETU 和 RFC。
- 可修改的参数可能导致参数被意外修改。
- 可修改的返回值可能导致实现为了防止意外修改进行**防御性复制**（如实现缓存了一部分结果，但直接返回缓存可能导致缓存被客户端修改），从而造成性能损失。而不可修改的类型可以安全地让多个客户端读取同一块内存。

总的来讲，可修改的对象会导致客户端与实现者之间的关系更加复杂，且难以修改，因为可修改对象往往牵扯到更多的程序状态。

同时，由于对象可以拥有多个**别名** (alias) （或者引用），一个模块所使用的对象有可能被持有别名的其他模块修改，进而引发漏洞。

## Designing Good Specifications
规范设计是模块设计的核心。

一个规范在形式上应该是简洁、清晰、结构化且易于理解的；而在内容上，尽管没有绝对的金科玉律，但存在一些实用的指导方针。

### Specs should be Coherent
规范应该足够清晰而易于理解：
- 即：一个模块应该作为一个单元（Unit），只做一件事。不要包含一长串参数，不要用一堆 flag 指定模块行为，不要有难以理解的逻辑，也不要处理很多的情况。

### Specs must Carefully Consider Mutation
## Precondition or Postcondition?
由于过强的前置条件可能导致模块难以使用，增加了客户端不必要的负担，因此好的规范在处理异常参数时，往往会作为后置条件的补充，要求实现事先检查参数的合法性，如果不合法，就抛出异常/返回特殊值。

然而，有时前置条件的检查会严重增加模块的负担，此时就不适合将参数检查加入后置条件。

因此，将参数条件放入前置条件或者后置条件是工程上的权衡，取决于**检查所需的开销**以及**模块的使用范围**。