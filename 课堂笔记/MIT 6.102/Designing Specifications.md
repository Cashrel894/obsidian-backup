#mit6102 
## Deterministic vs. Underdeterministic specs
如果对于一个**满足前置条件**的输入，其结果完全确定，不随具体实现的替换而变化，那么就称这个规范是**确定的**(Deterministic)。

而结果不确定的，就称这个规范是**欠定的**(Underdeterministic)。注意，一个欠定的规范，可能是因为具体实现涉及到了随机过程，导致同一实现对于同一输出可能有着不同结果；也可能是因为，规范对后置条件的约束不足，合法的结果非唯一，返回哪个结果是由具体实现决定的（而实现本身可以是确定的）。

## Declarative vs. Operational specs
如果一个规范详细描述了模块执行的一系列步骤，就称其为**操作式的**(Operational)；反之，若规范只描述了最终结果的性质以及与初始状态的关系，就称其为**声明式的**(Declarative)。

通常，声明式的规范总是好于操作性的，因为它们简短、易于理解，同时也成功向客户端隐藏了实现细节，给具体实现更大的自由度。

## Stronger vs. Weaker specs
有时，我们不仅需要修改实现，还可能要修改规范本身。那么，在有很多客户端使用该模块的情况下，我们应该怎样替换规范，防止破坏客户端的正确性呢？

我们可以比较两个规范之间的**强度**。如果规范 2 的合法实现是规范 1 的合法实现的真子集，就称规范 2 **强于**(Stronger) 规范 1。

更进一步说，规范 2 强于规范 1 当且仅当：
- 规范 2 的前置条件弱于规范 1。
- **当满足规范 1 的前置条件时**，规范 2 的后置条件强于规范 1。
若规范 2 强于规范 1，那么满足规范 2 的实现也必然满足规范 1，我们就可以安全地用规范 2 来替换掉规范 1。

## Mutability
从结论上讲，**不可修改的**类型总是比可修改的类型更加 SFB、ETU 和 RFC。